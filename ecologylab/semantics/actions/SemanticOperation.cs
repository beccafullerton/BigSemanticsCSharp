//
//  SemanticOperation.cs
//  s.im.pl serialization
//
//  Generated by DotNetTranslator on 11/16/10.
//  Copyright 2010 Interface Ecology Lab. 
//

using System;
using System.Collections.Generic;
using System.IO;
using Simpl.Fundamental.Net;
using Simpl.Serialization.Attributes;
using ecologylab.collections;
using ecologylab.semantics.collecting;
using ecologylab.semantics.connectors;
using ecologylab.semantics.documentparsers;
using ecologylab.semantics.metadata;
using ecologylab.semantics.metadata.builtins;
using ecologylab.semantics.metadata.scalar;
using ecologylab.semantics.metametadata;
using Simpl.Serialization;
using ecologylabSemantics.ecologylab.semantics.actions;

namespace ecologylab.semantics.actions 
{
    /// <summary>
    /// This is the abstract class which defines the semantic action. All the semantic actions must
    /// extend it. To add a new semantic action following steps needed to be taken. 
    /// <li> 1) Create a class for  that semantic action which extends SemanticAction class.
    /// </li><li> 2) Write all the custom code for that
    /// semantic action in this new class file. [Example see <code>ForEachSemanticAction.java</code> or
    /// <code>IfSemanticAction</code> which implements for_each semantic action.] 
    /// </li><li> 3) Modify the <code>handleSemanticAction</code> method of 
    /// <code>SemanticActionHandle.java</code> to add case
    /// for new semantic action. 
    /// </li><li> 4) Add a new method in <code>SemanticActionHandler.java </code> to
    /// handle this action. Mostly this method should be abstract unless the action is a flow control
    /// action like FOR LOOP. 
    /// </li><li> 5) For code clarity and readability define a constant for the new action
    /// name in <code>SemanticActionStandardMethods.java</code>
    /// </li>
    /// @author amathur
    /// </summary>
    public abstract class SemanticOperation : ElementState
    {
        /// <summary>
        /// missing java doc comments or could not find the source file.
        /// </summary>
        [SimplCollection]
        [SimplScope("condition_scope")]
        [SimplNoWrap]
        private List<Condition> checks;

        /// <summary>
        /// The map of arguments for this semantic action.
        /// </summary>
        [SimplNoWrap]
        [SimplMap("arg")]
        private Dictionary<String, Argument> args;

        /// <summary>
        /// Object on which the Action is to be taken
        /// </summary>
        [SimplScalar]
        [SimplTag("object")]
        private String objectStr;

        /// <summary>
        /// The value returned from the action
        /// </summary>
        [SimplScalar]
        private String name;

        /// <summary>
        /// Error string for this action
        /// </summary>
        [SimplScalar]
        private String error;

        public List<Condition> Checks
        {
            get { return checks; }
            set { checks = value; }
        }

        public Dictionary<String, Argument> Args
        {
            get { return args; }
            set { args = value; }
        }

        public String ObjectStr
        {
            get { return objectStr; }
            set { objectStr = value; }
        }

        public String Name
        {
            get { return name; }
            set { name = value; }
        }

        public String Error
        {
            get { return error; }
            set { error = value; }
        }



        protected SemanticsGlobalScope sessionScope;

        protected SemanticOperationHandler semanticOperationHandler;

        protected DocumentParser documentParser;

        public SemanticOperation()
        {
            args = new Dictionary<string, Argument>();
        }

        public String GetReturnObjectName()
        {
            return name;
        }

        public bool HasArguments()
        {
            return args != null && args.Count > 0;
        }

        public String GetArgumentValueName(String argName)
        {
            String result = null;
            if (args != null)
            {
                Argument argument = args[argName]; //edit
                if (argument != null) 
                {
                    result = argument.Value;
                }
            }
            return result;
        }

        public String GetArgumentAltValueName(String argName)
        {
            String result = null;
            if (args != null)
            {
                Argument argument = args[argName]; //edit
                if (argument != null) 
                {
                    result = argument.AltValue;
                }
            }
            return result;
        }

        public Object GetArgumentObject(String argName)
        {
            Object result = null;
            if (args != null)
            {
                    if (args.ContainsKey(argName))
                    {
                    Argument argument = args[argName];
                    String argumentValueName = argument.Value;
                    if (argumentValueName != null)
                    {
                        Scope<Object> semanticOperationVariableMap = semanticOperationHandler.SemanticOperationVariableMap;
                        result = semanticOperationVariableMap.Get(argumentValueName); //edit				
                        if (result == null)
                        {
                            argumentValueName = argument.AltValue;
                            if (argumentValueName != null)
                            {
                                result = semanticOperationVariableMap.Get(argumentValueName); //edit				
                            }
                        }
                    }
                    if (result != null && result is MetadataScalarBase<Object>)
                        result = ((MetadataScalarBase<Object>) result).Value; //edit
                }
            }
            return result;
        }

        public int GetArgumentInteger(String argName, int defaultValue)
        {
            int? value = (int?) GetArgumentObject(argName);
            return value.GetValueOrDefault();
        }

        public bool GetArgumentBoolean(String argName, bool defaultValue)
        {
            bool? value = (bool?) GetArgumentObject(argName);
            return value.GetValueOrDefault();
        }

        public float GetArgumentFloat(String argName, float defaultValue)
        {
            float? value = (float?) GetArgumentObject(argName);
            return value.GetValueOrDefault();
        }

        public SemanticsGlobalScope SessionScope
        {
            set { this.sessionScope = value; }
        }

        public SemanticOperationHandler SemanticOperationHandler
        {
            get { return this.semanticOperationHandler; }
            set { this.semanticOperationHandler = value; }
        }

        public DocumentParser DocumentParser
        {
            set { this.documentParser = documentParser; }
        }

        /// <summary>
        /// return the name of the operation.
        /// </summary>
        public abstract string GetOperationName();

        /// <summary>
        /// handle error during operation performing.
        /// </summary>
        public abstract void HandleError();

        /// <summary>
        /// Perform this semantic operation. User defined semantic operations should override this method
        /// </summary>
        /// <param name="obj">
        /// The object the operation operates on
        /// </param>
        /// <returns>
        /// The result of this semantic operation (if any), or null.
        /// </returns>
        public abstract object Perform(object obj);

        /// <summary>
        /// Register a user defined semantic operation to the system. This method should be called before
        /// compiling or using the MetaMetadata repository.
        /// <p />
        /// To override an existing semantic operation, subclass your own semantic operation class, use the same
        /// tag (indicated in @simpl_tag), and override perform().
        /// @param semanticOperationClass
        /// @param canBeNested
        ///          indicates if this semantic operation can be nested by other semantic operations, like
        ///          <code>for</code> or <code>if</code>. if so, it will also be registered to
        ///          NestedSemanticOperationTranslationScope.
        /// </summary>
        public static void Register(Type[] semanticOperationClasses)
        {
            foreach (Type semanticOperationClass in semanticOperationClasses)
            {
                SemanticOperationTranslationScope.Get().AddTranslation(semanticOperationClass);
            }
        }

        protected MetaMetadata GetMetaMetadata()
        {
            return GetMetaMetadata(this);
        }

        static public MetaMetadata GetMetaMetadata(ElementState that)
        {
            if (that is MetaMetadata)
            {
                return (MetaMetadata) that;
            }
            ElementState parent	= that.Parent;

            return (parent == null) ? null : GetMetaMetadata(parent);
        }

        protected Document ResolveSourceDocument()
        {
            Document sourceDocument = (Document)GetArgumentObject(SemanticOperationNamedArguments.SourceDocument);
            if (sourceDocument == null)
            {
                sourceDocument = this.semanticOperationHandler.SemanticOperationVariableMap[SemanticOperationKeyWords.Metadata] as Document;
                //sourceDocument = documentParser.Document;
            }

            return sourceDocument;
        }

        public Document GetOrCreateDocument(DocumentParser documentParser/*, LinkType linkType*/)
        {
            Document result = (Document) GetArgumentObject(SemanticOperationNamedArguments.Document);
            // get the ancestor container
            Document sourceDocument = ResolveSourceDocument();

            // get the seed. Non null only for search types .
            //Seed seed = documentParser.getSeed();					

            if (result == null)
            {
                Object outlinkPurlObject = GetArgumentObject(SemanticOperationNamedArguments.Location);

                if (outlinkPurlObject != null)
                {
                    ParsedUri outlinkPurl = ((MetadataParsedURL) outlinkPurlObject).Value;
                    result = sessionScope.GetOrConstructDocument(outlinkPurl);
                }
            }

            if (result == null)
                result = sourceDocument;	//direct binding?!

            if (result != null /*&& !result.IsRecycled()*/ && (result.Location != null))
            {
                result.SemanticsSessionScope = (SemanticsSessionScope) sessionScope;

                Metadata mixin = (Metadata) GetArgumentObject(SemanticOperationNamedArguments.Mixin);
                if (mixin != null)
                    result.AddMixin(mixin);

                /*if (seed != null)
                {
                    seed.bindToDocument(result);
                }*/
        
                MetadataString anchorText = (MetadataString) GetArgumentObject(SemanticOperationNamedArguments.AnchorText);
                // create anchor text from Document title if there is none passed in directly, and we won't
                // be setting metadata
                if (anchorText == null)
                    anchorText = result.Title;

                // work to avoid honey pots!
                MetadataString anchorContextString = (MetadataString) GetArgumentObject(SemanticOperationNamedArguments.AnchorContext);
                bool citationSignificance = GetArgumentBoolean(SemanticOperationNamedArguments.CitationSignificance, false);
                float significanceVal = GetArgumentFloat(SemanticOperationNamedArguments.SignificanceValue, 1);
                bool traversable = GetArgumentBoolean(SemanticOperationNamedArguments.Traversable, true);
                bool ignoreContextForTv = GetArgumentBoolean(SemanticOperationNamedArguments.IgnoreContextForTv, false);

                ParsedUri location = result.Location.Value;
            }
            // adding the return value to map
            Scope<Object> semanticActionVariableMap = SemanticOperationHandler.SemanticOperationVariableMap;
            if (semanticActionVariableMap != null)
            {
            if (GetReturnObjectName() != null)
                semanticActionVariableMap.Put(GetReturnObjectName(), result);
            }
            else
            Console.WriteLine("semanticActionVariableMap is null !! Not frequently reproducible either. Place a breakpoint here to try fixing it next time.");
            // set flags if any
            // setFlagIfAny(action, localContainer);

            // return the value. Right now no need for it. Later it might be used.
            return result;
        }

        public static readonly int INIT = 0; // this operation has not been started
        public static readonly int INTER = 10; // this operation has been started but not yet finished
        public static readonly int FIN = 20; // this operation has already been finished

        public virtual void SetNestedOperationState(String name, Object value)
        {
        }

        public SemanticOperationHandler GetSemanticOperationHandler()
        {
            SemanticOperationHandler result = this.semanticOperationHandler;
            if (result == null)
            {
                ElementState parentES = Parent;
                if (parentES != null && parentES is SemanticOperation)
                {
                    SemanticOperation parent = (SemanticOperation) parentES;
                    result = parent.GetSemanticOperationHandler();
                    this.semanticOperationHandler = result;
                }
            }
            return result;
        }
    }
}
