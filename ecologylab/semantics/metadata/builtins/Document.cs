//
//  Document.cs
//  s.im.pl serialization
//
//  Generated by DotNetTranslator on 02/09/11.
//  Copyright 2011 Interface Ecology Lab. 
//

using System;
using System.Collections.Generic;
using Simpl.Fundamental.Net;
using Simpl.Serialization.Attributes;
using ecologylab.semantics.collecting;
using ecologylab.semantics.metadata.builtins.declarations;
using ecologylab.semantics.metadata.scalar;
using ecologylab.semantics.metadata;
using ecologylab.semantics.metametadata;
using System.IO;

namespace ecologylab.semantics.metadata.builtins 
{
    [SimplInherit]
    public class Document : DocumentDeclaration
    {

        [MmName("generation")]
        [SimplScalar]
        private MetadataInteger generation;

        [MmName("favicon")]
        [SimplScalar]
        private MetadataParsedURL favicon;

        public Document()
        { }

        public Document(MetaMetadataCompositeField metaMetadata) : base(metaMetadata) { }

        public MetadataInteger Generation
        {
            get{return generation;}
            set{if (this.generation != value) { this.generation = value; this.RaisePropertyChanged(() => this.Generation); }}
        }

        public MetadataParsedURL Favicon
        {
            get{return favicon;}
            set{if (this.favicon != value) { this.favicon = value; this.RaisePropertyChanged(() => this.Favicon); }}
        }

        #region Runtime Properties

        public SemanticsSessionScope SemanticsSessionScope { get; set; }

        #endregion

        public override String ToString()
        {
            return (Title != null) ? Title.Value : base.ToString();
        }

        public void AddAdditionalLocation(MetadataParsedURL additionalLocation)
        {
            if (AdditionalLocations == null)
                AdditionalLocations = new List<MetadataParsedURL>();
            AdditionalLocations.Add(additionalLocation);
        }

        public void InheritValues(Document oldDocument)
        {
            oldDocument.SemanticsSessionScope.GlobalDocumentCollection.Remap(oldDocument, this);

            if (Location == null)
            {
                Location = oldDocument.Location;
                oldDocument.Location = null;
            }

            this.SemanticsSessionScope = oldDocument.SemanticsSessionScope;

            // TODO semantic inlinks

            List<Metadata> oldMixins = oldDocument.Mixins;
            if (oldMixins != null)
                foreach (Metadata oldMixin in oldMixins)
                    AddMixin(oldMixin);

            List<MetadataParsedURL> oldAdditionalLocations = oldDocument.AdditionalLocations;
            if (oldAdditionalLocations != null)
                foreach (MetadataParsedURL otherLocation in oldAdditionalLocations)
                    AddAdditionalLocation(otherLocation);
        }

        public void DownloadAndParseDone()
        {
            // hook for subclasses to perform actions after parsing done.
            // currently, for CompoundDocument to create and visualize clippings.
            // as clipping creation and visualization goes to semantic actions, do we still need this ??
        }

        public ParsedUri DownloadLocation
        {
            get
            {
                ParsedUri result	    = Location.Value;
		        ParsedUri localLocation	= LocalLocation.Value;
		        if (localLocation != null)
		        {
			        FileInfo localFile	= localLocation.File;
			        if (localFile.Exists)
				        result	= localLocation;
		        }
		        return result;
            }
        }

    }   
}
